<!doctype html>
<html class="no-js" lang="zxx">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
         <title>article</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="manifest" href="site.webmanifest">
		<link rel="shortcut icon" type="image/x-icon" href="assets/img/icon_n.png">

		<!-- CSS here -->
            <link rel="stylesheet" href="assets/css/bootstrap.min.css">
            <link rel="stylesheet" href="assets/css/owl.carousel.min.css">
            <link rel="stylesheet" href="assets/css/ticker-style.css">
            <link rel="stylesheet" href="assets/css/flaticon.css">
            <link rel="stylesheet" href="assets/css/slicknav.css">
            <link rel="stylesheet" href="assets/css/animate.min.css">
            <link rel="stylesheet" href="assets/css/magnific-popup.css">
            <link rel="stylesheet" href="assets/css/fontawesome-all.min.css">
            <link rel="stylesheet" href="assets/css/themify-icons.css">
            <link rel="stylesheet" href="assets/css/slick.css">
            <link rel="stylesheet" href="assets/css/nice-select.css">
            <link rel="stylesheet" href="assets/css/style.css">
            <link rel="stylesheet" href="assets/css/responsive.css">
   </head>

   <body>
       
    <!-- Preloader Start -->
    <div id="preloader-active">
        <div class="preloader d-flex align-items-center justify-content-center">
            <div class="preloader-inner position-relative">
                <div class="preloader-circle"></div>
                <div class="preloader-img pere-text">
                    <img src="assets/img/logo/logo_CODE2.png" alt="">
                </div>
            </div>
        </div>
    </div>
    <!-- Preloader Start -->
    <div data-include="header"></div>
    <main>
        <div class="post__wrapper">

            <div class="container">
              <br>
              <div class="post__wrapper">
               
                <h1 class="post__title post__title_full">
                  <span class="post__title-text">Indexes in PostgreSQL — 4 (Btree)</span>
                </h1>
            
                  <div class="post__translatation">
                    <a href="https://habr.com/ru/company/postgrespro/blog/330544/" class="post__translatation-link" title="Original author: Egor Rogov" target="_blank" rel=" noopener">Original author: Egor Rogov</a>
                  </div>
            
                <div class="post__body post__body_full">
                  <div class="post__text post__text-html post__text_v1" id="post-content-body">We've already discussed PostgreSQL <a href="https://habr.com/ru/company/postgrespro/blog/441962/">indexing engine</a> and <a href="https://habr.com/ru/company/postgrespro/blog/442546/">interface of access methods</a>, as well as <a href="https://habr.com/post/442776/">hash index</a>, one of access methods. We will now consider B-tree, the most traditional and widely used index. This article is large, so be patient.<br>
            <br>
            <h1>Btree</h1><br>
            <h2>Structure</h2><br>
            B-tree index type, implemented as «btree» access method, is suitable for data that can be sorted. In other words, «greater», «greater or equal», «less», «less or equal», and «equal» operators must be defined for the data type. Note that the same data can sometimes be sorted differently, which <a href="https://habr.com/ru/company/postgrespro/blog/442546">takes us back</a> to the concept of operator family.<br>
            <a name="habracut"></a><br>
            As always, index rows of the B-tree are packed into pages. In leaf pages, these rows contain data to be indexed (keys) and references to table rows (TIDs). In internal pages, each row references a child page of the index and contains the minimal value in this page.<br>
            <br>
            B-trees have a few important traits:<br>
            <br>
            <ul>
            <li>B-trees are balanced, that is, each leaf page is separated from the root by the same number of internal pages. Therefore, search for any value takes the same time.<br>
            </li>
            <li>B-trees are multi-branched, that is, each page (usually 8&nbsp;KB) contains a lot of (hundreds) TIDs. As a result, the depth of B-trees is pretty small, actually up to 4–5 for very large tables.<br>
            </li>
            <li>Data in the index is sorted in nondecreasing order (both between pages and inside each page), and same-level pages are connected to one another by a bidirectional list. Therefore, we can get an ordered data set just by a list walk one or the other direction without returning to the root each time.<br>
            </li>
            </ul><br>
            Below is a simplified example of the index on one field with integer keys.<br>
            <br>
            <img src="https://habrastorage.org/web/2e4/4f4/003/2e44f400317048c78e4cec04ab45e48e.png"><br>
            <br>
            The very first page of the index is a metapage, which references the index root. Internal nodes are located below the root, and leaf pages are in the bottommost row. Down arrows represent references from leaf nodes to table rows (TIDs).<br>
            <br>
            <h3>Search by equality</h3><br>
            Let's consider search of a value in a tree by condition "<em>indexed-field</em> = <em>expression</em>". Say, we are interested in the key of 49.<br>
            <br>
            <img src="https://habrastorage.org/web/9fd/814/c9e/9fd814c9e79443b2a774403a817bf734.png"><br>
            <br>
            The search starts with the root node, and we need to determine to which of the child nodes to descend. Being aware of the keys in the root node (4, 32, 64), we therefore figure out the value ranges in child nodes. Since 32 ≤ 49 &lt; 64, we need to descend to the second child node. Next, the same process is recursively repeated until we reach a leaf node from which the needed TIDs can be obtained.<br>
            <br>
            In reality, a number of particulars complicate this seemingly simple process. For example, an index can contain non-unique keys and there can be so many equal values that they do not fit one page. Getting back to our example, it seems that we should descend from the internal node over the reference to the value of 49. But, as clear from the figure, this way we will skip one of the «49» keys in the preceding leaf page. Therefore, once we've found an exactly equal key in an internal page, we have to descend one position left and then look through index rows of the underlying level from left to right in search of the sought key.<br>
            <br>
            (Another complication is that during the search other processes can change the data: the tree can be rebuilt, pages can be split into two, etc. All algorithms are engineered for these concurrent operations not to interfere with one another and not to cause extra locks wherever possible. But we will avoid expanding on this.)<br>
            <br>
            <h3>Search by inequality</h3><br>
            When searching by the condition "<em>indexed-field</em> ≤ <em>expression</em>" (or "<em>indexed-field</em> ≥ <em>expression</em>"), we first find a value (if any) in the index by the equality condition "<em>indexed-field</em> = <em>expression</em>" and then walk through leaf pages in the appropriate direction to the end.<br>
            <br>
            The figure illustrates this process for n ≤ 35:<br>
            <br>
            <img src="https://habrastorage.org/web/35e/62a/f80/35e62af80ca44349b7728ad806226208.png"><br>
            <br>
            The «greater» and «less» operators are supported in a similar way, except that the value initially found must be dropped.<br>
            <br>
            <h3>Search by range</h3><br>
            When searching by range "<em>expression1</em> ≤ <em>indexed-field</em> ≤ <em>expression2</em>", we find a value by condition "<em>indexed-field</em> = <em>expression1</em>", and then keep walking through leaf pages while the condition "<em>indexed-field</em> ≤ <em>expression2</em>" is met; or vice versa: start with the second expression and walk in an opposite direction until we reach the first expression.<br>
            <br>
            The figure shows this process for condition 23 ≤ n ≤ 64:<br>
            <br>
            <img src="https://habrastorage.org/web/2d6/b24/d86/2d6b24d86fb24c9ab437cc8155658e58.png"><br>
            <br>
            <h2>Example</h2><br>
            Let's look at an example of what query plans look like. As usual, we use the demo database, and this time we will consider the aircraft table. It contains as few as nine rows, and the planner would choose not to use the index since the entire table fits one page. But this table is interesting to us for an illustrative purpose.<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> aircrafts;
            </code></pre><pre><code class="plaintext hljs"> aircraft_code |        model        | range 
            ---------------+---------------------+-------
             773           | Boeing 777-300      | 11100
             763           | Boeing 767-300      |  7900
             SU9           | Sukhoi SuperJet-100 |  3000
             320           | Airbus A320-200     |  5700
             321           | Airbus A321-200     |  5600
             319           | Airbus A319-100     |  6700
             733           | Boeing 737-300      |  4200
             CN1           | Cessna 208 Caravan  |  1200
             CR2           | Bombardier CRJ-200  |  2700
            (9 rows)
            </code></pre><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">on</span> aircrafts(range);
            
            demo=# <span class="hljs-keyword">set</span> enable_seqscan = <span class="hljs-keyword">off</span>;
            </code></pre><br>
            (Or explicitly, «create index on aircrafts using btree(range)», but it's a B-tree that is built by default.)<br>
            <br>
            Search by equality:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>) <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> aircrafts <span class="hljs-keyword">where</span> range = <span class="hljs-number">3000</span>;
            </code></pre><pre><code class="plaintext hljs">                    QUERY PLAN                     
            ---------------------------------------------------
             Index Scan using aircrafts_range_idx on aircrafts
               Index Cond: (range = 3000)
            (2 rows)
            </code></pre><br>
            Search by inequality:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>) <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> aircrafts <span class="hljs-keyword">where</span> range &lt; <span class="hljs-number">3000</span>;
            </code></pre><pre><code class="plaintext hljs">                    QUERY PLAN                    
            ---------------------------------------------------
             Index Scan using aircrafts_range_idx on aircrafts
               Index Cond: (range &lt; 3000) 
            (2 rows)
            </code></pre><br>
            And by range:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>) <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> aircrafts
            <span class="hljs-keyword">where</span> <span class="hljs-keyword">range</span> <span class="hljs-keyword">between</span> <span class="hljs-number">3000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5000</span>;
            </code></pre><pre><code class="plaintext hljs">                     QUERY PLAN                      
            -----------------------------------------------------
             Index Scan using aircrafts_range_idx on aircrafts
               Index Cond: ((range &gt;= 3000) AND (range &lt;= 5000))
            (2 rows)
            </code></pre><br>
            <h2>Sorting</h2><br>
            Let's once again emphasize the point that with any kind of scan (index, index-only, or bitmap), «btree» access method returns ordered data, which we can clearly see in the above figures.<br>
            <br>
            Therefore, if a table has an index on the sort condition, the optimizer will consider both options: index scan of the table, which readily returns sorted data, and sequential scan of the table with subsequent sorting of the result.<br>
            <br>
            <h3>Sort order</h3><br>
            When creating an index we can explicitly specify the sort order. For example, we can create an index by flight ranges this way in particular:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">on</span> aircrafts(range <span class="hljs-keyword">desc</span>);
            </code></pre><br>
            In this case, larger values would appear in the tree on the left, while smaller values would appear on the right. Why can this be needed if we can walk through indexed values in either direction?<br>
            <br>
            The purpose is multi-column indexes. Let's create a view to show aircraft models with a conventional division into short-, middle-, and long-range craft:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> aircrafts_v <span class="hljs-keyword">as</span>
            <span class="hljs-keyword">select</span> model,
                   <span class="hljs-keyword">case</span>
                       <span class="hljs-keyword">when</span> range &lt; <span class="hljs-number">4000</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span>
                       <span class="hljs-keyword">when</span> range &lt; <span class="hljs-number">10000</span> <span class="hljs-keyword">then</span> <span class="hljs-number">2</span>
                       <span class="hljs-keyword">else</span> <span class="hljs-number">3</span>
                   <span class="hljs-keyword">end</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">class</span>
            <span class="hljs-keyword">from</span> aircrafts;
            
            demo=# <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> aircrafts_v;
            </code></pre><pre><code class="plaintext hljs">        model        | class
            ---------------------+-------
             Boeing 777-300      |     3
             Boeing 767-300      |     2
             Sukhoi SuperJet-100 |     1
             Airbus A320-200     |     2
             Airbus A321-200     |     2
             Airbus A319-100     |     2
             Boeing 737-300      |     2
             Cessna 208 Caravan  |     1
             Bombardier CRJ-200  |     1
            (9 rows)
            </code></pre><br>
            And let's create an index (using the expression):<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">on</span> aircrafts(
              (<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> range &lt; <span class="hljs-number">4000</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">when</span> range &lt; <span class="hljs-number">10000</span> <span class="hljs-keyword">then</span> <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">3</span> <span class="hljs-keyword">end</span>),
              model);
            </code></pre><br>
            Now we can use this index to get data sorted by both columns in ascending order:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">select</span> <span class="hljs-keyword">class</span>, model <span class="hljs-keyword">from</span> aircrafts_v <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">class</span>, model;
            </code></pre><pre><code class="plaintext hljs"> class |        model        
            -------+---------------------
                 1 | Bombardier CRJ-200
                 1 | Cessna 208 Caravan
                 1 | Sukhoi SuperJet-100
                 2 | Airbus A319-100
                 2 | Airbus A320-200
                 2 | Airbus A321-200
                 2 | Boeing 737-300
                 2 | Boeing 767-300
                 3 | Boeing 777-300
            (9 rows)
            </code></pre><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)
            <span class="hljs-keyword">select</span> <span class="hljs-keyword">class</span>, model <span class="hljs-keyword">from</span> aircrafts_v <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">class</span>, model;
            </code></pre><pre><code class="plaintext hljs">                       QUERY PLAN                       
            --------------------------------------------------------
             Index Scan using aircrafts_case_model_idx on aircrafts
            (1 row)
            </code></pre><br>
            Similarly, we can perform the query to sort data in descending order:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">select</span> <span class="hljs-keyword">class</span>, model <span class="hljs-keyword">from</span> aircrafts_v <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">desc</span>, model <span class="hljs-keyword">desc</span>;
            </code></pre><pre><code class="plaintext hljs"> class |        model        
            -------+---------------------
                 3 | Boeing 777-300
                 2 | Boeing 767-300
                 2 | Boeing 737-300
                 2 | Airbus A321-200
                 2 | Airbus A320-200
                 2 | Airbus A319-100
                 1 | Sukhoi SuperJet-100
                 1 | Cessna 208 Caravan
                 1 | Bombardier CRJ-200
            (9 rows)
            </code></pre><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)
            <span class="hljs-keyword">select</span> <span class="hljs-keyword">class</span>, model <span class="hljs-keyword">from</span> aircrafts_v <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">desc</span>, model <span class="hljs-keyword">desc</span>;
            </code></pre><pre><code class="plaintext hljs">                           QUERY PLAN                            
            -----------------------------------------------------------------
             Index Scan BACKWARD using aircrafts_case_model_idx on aircrafts
            (1 row)
            </code></pre><br>
            However, we cannot use this index to get data sorted by one column in descending order and by the other column in ascending order. This will require sorting separately:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)
            <span class="hljs-keyword">select</span> <span class="hljs-keyword">class</span>, model <span class="hljs-keyword">from</span> aircrafts_v <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">ASC</span>, model <span class="hljs-keyword">DESC</span>;
            </code></pre><pre><code class="plaintext hljs">                   QUERY PLAN                    
            -------------------------------------------------
             Sort
               Sort Key: (CASE ... END), aircrafts.model DESC
               -&gt;  Seq Scan on aircrafts
            (3 rows)
            </code></pre><br>
            (Note that, as a last resort, the planner chose sequential scan regardless of «enable_seqscan = off» setting made earlier. This is because actually this setting does not forbid table scanning, but only sets its astronomic cost — please look at the plan with «costs on».)<br>
            <br>
            To make this query use the index, the latter must be built with the needed sort direction:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> aircrafts_case_asc_model_desc_idx <span class="hljs-keyword">on</span> aircrafts(
             (<span class="hljs-keyword">case</span>
                <span class="hljs-keyword">when</span> range &lt; <span class="hljs-number">4000</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span>
                <span class="hljs-keyword">when</span> range &lt; <span class="hljs-number">10000</span> <span class="hljs-keyword">then</span> <span class="hljs-number">2</span>
                <span class="hljs-keyword">else</span> <span class="hljs-number">3</span>
              <span class="hljs-keyword">end</span>) <span class="hljs-keyword">ASC</span>,
              model <span class="hljs-keyword">DESC</span>);
            
            demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)
            <span class="hljs-keyword">select</span> <span class="hljs-keyword">class</span>, model <span class="hljs-keyword">from</span> aircrafts_v <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">ASC</span>, model <span class="hljs-keyword">DESC</span>;
            </code></pre><pre><code class="plaintext hljs">                           QUERY PLAN                            
            -----------------------------------------------------------------
             Index Scan using aircrafts_case_asc_model_desc_idx on aircrafts
            (1 row)
            </code></pre><br>
            <h3>Order of columns</h3><br>
            Another issue that arises when using multi-column indexes is the order of listing columns in an index. For B-tree, this order is of huge importance: the data inside pages will be sorted by the first field, then by the second one, and so on.<br>
            <br>
            We can represent the index that we built on range intervals and models in a symbolic way as follows:<br>
            <br>
            <img src="https://habrastorage.org/web/90c/71b/c8b/90c71bc8b51441b7b3c0df21b6a8888b.png"><br>
            <br>
            Actually such a small index will for sure fit one root page. In the figure, it is deliberately distributed among several pages for clarity.<br>
            <br>
            It is clear from this chart that search by predicates like «class = 3» (search only by the first field) or «class = 3 and model = 'Boeing 777-300'» (search by both fields) will work efficiently.<br>
            <br>
            However, search by the predicate «model = 'Boeing 777-300'» will be way less efficient: starting with the root, we cannot determine to which child node to descend, therefore, we will have to descend to all of them. This does not mean that an index like this cannot ever be used — its efficiency is at issue. For example, if we had three classes of aircraft and a great many models in each class, we would have to look through about one third of the index and this might have been more efficient than the full table scan… or not.<br>
            <br>
            However, if we create an index like this:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">on</span> aircrafts(
              model,
              (<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> range &lt; <span class="hljs-number">4000</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">when</span> range &lt; <span class="hljs-number">10000</span> <span class="hljs-keyword">then</span> <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">3</span> <span class="hljs-keyword">end</span>));
            </code></pre><br>
            the order of fields will change:<br>
            <br>
            <img src="https://habrastorage.org/web/458/c5f/d22/458c5fd22e26467d9f0c56e308d8db5f.png"><br>
            <br>
            With this index, search by the predicate «model = 'Boeing 777-300'» will work efficiently, but search by the predicate «class = 3» will not.<br>
            <br>
            <h3>NULLs</h3><br>
            «btree» access method indexes NULLs and supports search by conditions IS NULL and IS NOT NULL.<br>
            <br>
            Let's consider the table of flights, where NULLs occur:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">on</span> flights(actual_arrival);
            
            demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>) <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> flights <span class="hljs-keyword">where</span> actual_arrival <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;
            </code></pre><pre><code class="plaintext hljs">                      QUERY PLAN                       
            -------------------------------------------------------
             Bitmap Heap Scan on flights
               Recheck Cond: (actual_arrival IS NULL)
               -&gt;  Bitmap Index Scan on flights_actual_arrival_idx
                     Index Cond: (actual_arrival IS NULL)
            (4 rows)
            </code></pre><br>
            NULLs are located on one or the other end of leaf nodes depending on how the index was created (NULLS FIRST or NULLS LAST). This is important if a query includes sorting: the index can be used if the SELECT command specifies the same order of NULLs in its ORDER BY clause as the order specified for the built index (NULLS FIRST or NULLS LAST).<br>
            <br>
            In the following example, these orders are the same, therefore, we can use the index:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)
            <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> flights <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> actual_arrival <span class="hljs-keyword">NULLS LAST</span>;
            </code></pre><pre><code class="plaintext hljs">                       QUERY PLAN                      
            --------------------------------------------------------
             Index Scan using flights_actual_arrival_idx on flights
            (1 row)
            </code></pre><br>
            And here these orders are different, and the optimizer chooses sequential scan with subsequent sorting:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)
            <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> flights <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> actual_arrival <span class="hljs-keyword">NULLS FIRST</span>;
            </code></pre><pre><code class="plaintext hljs">               QUERY PLAN              
            ----------------------------------------
             Sort
               Sort Key: actual_arrival NULLS FIRST
               -&gt;  Seq Scan on flights
            (3 rows)
            </code></pre><br>
            To use the index, it must be created with NULLs located at the beginning:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> flights_nulls_first_idx <span class="hljs-keyword">on</span> flights(actual_arrival <span class="hljs-keyword">NULLS FIRST</span>);
            
            demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)
            <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> flights <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> actual_arrival <span class="hljs-keyword">NULLS FIRST</span>;
            </code></pre><pre><code class="plaintext hljs">                     QUERY PLAN                      
            -----------------------------------------------------
             Index Scan using flights_nulls_first_idx on flights
            (1 row)
            </code></pre><br>
            Issues like this are certainly caused by NULLs not being sortable, that is, the result of comparison for NULL and any other value is undefined:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# \pset <span class="hljs-keyword">null</span> <span class="hljs-keyword">NULL</span>
            
            demo=# <span class="hljs-keyword">select</span> <span class="hljs-keyword">null</span> &lt; <span class="hljs-number">42</span>;
            </code></pre><pre><code class="plaintext hljs"> ?column?
            ----------
             NULL
            (1 row)
            </code></pre><br>
            This runs counter to the concept of B-tree and does not fit into the general pattern. NULLs, however, play such an important role in databases that we always have to make exceptions for them.<br>
            <br>
            Since NULLs can be indexed, it is possible to use an index even without any conditions imposed on the table (since the index contains information on all table rows for sure). This may make sense if the query requires data ordering and the index ensures the order needed. In this case, the planner can rather choose index access to save on separate sorting.<br>
            <br>
            <h2>Properties</h2><br>
            Let's look at properties of «btree» access method (queries <a href="https://habr.com/ru/company/postgrespro/blog/442546/">have already been provided</a>).<br>
            <br>
            <pre><code class="plaintext hljs"> amname |     name      | pg_indexam_has_property
            --------+---------------+-------------------------
             btree  | can_order     | t
             btree  | can_unique    | t
             btree  | can_multi_col | t
             btree  | can_exclude   | t
            </code></pre><br>
            As we've seen, B-tree can order data and supports uniqueness — and this is the only access method to provide us with properties like these. Multicolumn indexes are also permitted, but other access methods (although not all of them) may also support such indexes. We will discuss support of EXCLUDE constraint next time, and not without reason.<br>
            <br>
            <pre><code class="plaintext hljs">     name      | pg_index_has_property
            ---------------+-----------------------
             clusterable   | t
             index_scan    | t
             bitmap_scan   | t
             backward_scan | t
            </code></pre><br>
            «btree» access method supports both techniques to get values: index scan, as well as bitmap scan. And as we could see, the access method can walk through the tree both «forward» and «backward».<br>
            <br>
            <pre><code class="plaintext hljs">        name        | pg_index_column_has_property 
            --------------------+------------------------------
             asc                | t
             desc               | f
             nulls_first        | f
             nulls_last         | t
             orderable          | t
             distance_orderable | f
             returnable         | t
             search_array       | t
             search_nulls       | t
            </code></pre><br>
            First four properties of this layer explain how exactly values of a certain specific column are ordered. In this example, values are sorted in ascending order («asc») and NULLs are provided last («nulls_last»). But as we've already seen, other combinations are possible.<br>
            <br>
            «search_array» property indicates support of expressions like this by the index:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)
            <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> aircrafts <span class="hljs-keyword">where</span> aircraft_code <span class="hljs-keyword">in</span> (<span class="hljs-string">'733'</span>,<span class="hljs-string">'763'</span>,<span class="hljs-string">'773'</span>);
            </code></pre><pre><code class="plaintext hljs">                           QUERY PLAN                            
            -----------------------------------------------------------------
             Index Scan using aircrafts_pkey on aircrafts
               Index Cond: (aircraft_code = ANY ('{733,763,773}'::bpchar[]))
            (2 rows)
            </code></pre><br>
            «returnable» property indicates support of index-only scan, which is reasonable since rows of the index store indexed values themselves (unlike in hash index, for example). Here it makes sense to say a few words about covering indexes based on B-tree.<br>
            <br>
            <h3>Unique indexes with additional rows</h3><br>
            As we discussed <a href="https://habr.com/ru/company/postgrespro/blog/441962/">earlier</a>, a covering index is the one that stores all values needed for a query, access to the table itself not being required (nearly). A unique index can specifically be covering.<br>
            <br>
            But let's assume that we want to add extra columns needed for a query to the unique index. However, uniqueness of such composite values does not guarantee uniqueness of the key, and two indexes on the same columns will then be needed: one unique to support integrity constraint and another one to be used as covering. This is inefficient for sure.<br>
            <br>
            In our company Anastasiya Lubennikova <a href="https://habr.com/ru/users/lubennikovaav/" class="user_link">lubennikovaav</a> improved «btree» method so that additional, non-unique, columns could be included in a unique index. We hope, this patch will be adopted by the community to become a part of PostgreSQL, but this will not happen as early as in version 10. At this point, the patch is available in Pro Standard 9.5+, and this is what it looks like.<br>
            <br>
            <blockquote>In fact this patch was committed to PostgreSQL 11.<br>
            </blockquote><br>
            Let's consider the bookings table:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# \d bookings
            </code></pre><pre><code class="plaintext hljs">              Table "bookings.bookings"
                Column    |           Type           | Modifiers
            --------------+--------------------------+-----------
             book_ref     | character(6)             | not null
             book_date    | timestamp with time zone | not null
             total_amount | numeric(10,2)            | not null
            Indexes:
                "bookings_pkey" PRIMARY KEY, btree (book_ref)
            Referenced by:
                TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)
            </code></pre><br>
            In this table, the primary key (book_ref, booking code) is provided by a regular «btree» index. Let's create a new unique index with an additional column:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> <span class="hljs-keyword">index</span> bookings_pkey2 <span class="hljs-keyword">on</span> bookings(book_ref) <span class="hljs-keyword">INCLUDE</span> (book_date);
            </code></pre><br>
            Now we replace the existing index with a new one (in the transaction, to apply all changes simultaneously):<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">begin</span>;
            
            demo=# <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> bookings <span class="hljs-keyword">drop</span> <span class="hljs-keyword">constraint</span> bookings_pkey <span class="hljs-keyword">cascade</span>;
            
            demo=# <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> bookings <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary key</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">index</span> bookings_pkey2;
            
            demo=# <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tickets <span class="hljs-keyword">add</span> <span class="hljs-keyword">foreign key</span> (book_ref) <span class="hljs-keyword">references</span> bookings (book_ref);
            
            demo=# <span class="hljs-keyword">commit</span>;
            </code></pre><br>
            This is what we get:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# \d bookings
            </code></pre><pre><code class="plaintext hljs">              Table "bookings.bookings"
                Column    |           Type           | Modifiers
            --------------+--------------------------+-----------
             book_ref     | character(6)             | not null
             book_date    | timestamp with time zone | not null
             total_amount | numeric(10,2)            | not null
            Indexes:
                "bookings_pkey2" PRIMARY KEY, btree (book_ref) INCLUDE (book_date)
            Referenced by:
                TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)
            </code></pre><br>
            Now one and the same index works as unique and serves as a covering index for this query, for example:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">explain</span>(<span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>)
            <span class="hljs-keyword">select</span> book_ref, book_date <span class="hljs-keyword">from</span> bookings <span class="hljs-keyword">where</span> book_ref = <span class="hljs-string">'059FC4'</span>;
            </code></pre><pre><code class="plaintext hljs">                    QUERY PLAN                    
            --------------------------------------------------
             Index Only Scan using bookings_pkey2 on bookings
               Index Cond: (book_ref = '059FC4'::bpchar)
            (2 rows)
            </code></pre><br>
            <h2>Creation of the index</h2><br>
            It is well-known, yet no less important, that for a large-size table, it is better to load data there without indexes and create needed indexes later. This is not only faster, but most likely the index will have smaller size.<br>
            <br>
            The thing is that creation of «btree» index uses a more efficient process than row-wise insertion of values into the tree. Roughly, all data available in the table are sorted, and leaf pages of these data are created. Then internal pages are «built over» this base until the entire pyramid converges to the root.<br>
            <br>
            The speed of this process depends on the size of RAM available, which is limited by the «maintenance_work_mem» parameter. So, increasing the parameter value can speed up the process. For unique indexes, memory of size «work_mem» is allocated in addition to «maintenance_work_mem».<br>
            <br>
            <h3>Comparison semantics</h3><br>
            <a href="https://habr.com/ru/company/postgrespro/blog/442546/">Last time</a> we've mentioned that PostgreSQL needs to know which hash functions to call for values of different types and that this association is stored in «hash» access method. Likewise, the system must figure out how to order values. This is needed for sortings, groupings (sometimes), merge joins, and so on. PostgreSQL does not bind itself to operator names (such as &gt;, &lt;, =) since users can define their own data type and give corresponding operators different names. An operator family used by «btree» access method defines operator names instead.<br>
            <br>
            For example, these comparison operators are used in the «bool_ops» operator family:<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">select</span>   amop.amopopr::<span class="hljs-type">regoperator</span> <span class="hljs-keyword">as</span> opfamily_operator,
                     amop.amopstrategy
            <span class="hljs-keyword">from</span>     pg_am am,
                     pg_opfamily opf,
                     pg_amop amop
            <span class="hljs-keyword">where</span>    opf.opfmethod = am.oid
            <span class="hljs-keyword">and</span>      amop.amopfamily = opf.oid
            <span class="hljs-keyword">and</span>      am.amname = <span class="hljs-string">'btree'</span>
            <span class="hljs-keyword">and</span>      opf.opfname = <span class="hljs-string">'bool_ops'</span>
            <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> amopstrategy;
            </code></pre><pre><code class="plaintext hljs">  opfamily_operator  | amopstrategy
            ---------------------+-------------- 
             &lt;(boolean,boolean)  |            1
             &lt;=(boolean,boolean) |            2
             =(boolean,boolean)  |            3
             &gt;=(boolean,boolean) |            4
             &gt;(boolean,boolean)  |            5
            (5 rows) 
            </code></pre><br>
            Here we can see five comparison operators, but as already mentioned, we should not rely on their names. To figure out which comparison each operator does, the strategy concept is introduced. Five strategies are defined to describe operator semantics:<br>
            <br>
            <ul>
            <li>1 — less</li>
            <li>2 — less or equal</li>
            <li>3 — equal</li>
            <li>4 — greater or equal</li>
            <li>5 — greater</li>
            </ul><br>
            Some operator families can contain several operators implementing one strategy. For example, «integer_ops» operator family contains the following operators for strategy 1:<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">select</span>   amop.amopopr::<span class="hljs-type">regoperator</span> <span class="hljs-keyword">as</span> opfamily_operator
            <span class="hljs-keyword">from</span>     pg_am am,
                     pg_opfamily opf,
                     pg_amop amop
            <span class="hljs-keyword">where</span>    opf.opfmethod = am.oid
            <span class="hljs-keyword">and</span>      amop.amopfamily = opf.oid
            <span class="hljs-keyword">and</span>      am.amname = <span class="hljs-string">'btree'</span>
            <span class="hljs-keyword">and</span>      opf.opfname = <span class="hljs-string">'integer_ops'</span>
            <span class="hljs-keyword">and</span>      amop.amopstrategy = <span class="hljs-number">1</span>
            <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> opfamily_operator;
            </code></pre><pre><code class="plaintext hljs">  opfamily_operator  
            ---------------------- 
             &lt;(integer,bigint)
             &lt;(smallint,smallint)
             &lt;(integer,integer)
             &lt;(bigint,bigint)
             &lt;(bigint,integer)
             &lt;(smallint,integer)
             &lt;(integer,smallint)
             &lt;(smallint,bigint)
             &lt;(bigint,smallint)
            (9 rows) 
            </code></pre><br>
            Thanks to this, the optimizer can avoid type casts when comparing values of different types contained in one operator family.<br>
            <br>
            <h3>Index support for a new data type</h3><br>
            The documentation provides <a href="https://postgrespro.com/docs/postgrespro/9.6/xindex">an example</a> of creation of a new data type for complex numbers and of an operator class to sort values of this type. This example uses C language, which is absolutely reasonable when the speed is critical. But nothing hinders us from using pure SQL for the same experiment in order just to try and better understand the comparison semantics.<br>
            <br>
            Let's create a new composite type with two fields: real and imaginary parts.<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">type</span> complex <span class="hljs-keyword">as</span> (re <span class="hljs-type">float</span>, im <span class="hljs-type">float</span>);
            </code></pre><br>
            We can create a table with a field of the new type and add some values to the table:<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> numbers(x complex);
            
            postgres=# <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> numbers <span class="hljs-keyword">values</span> ((<span class="hljs-number">0.0</span>, <span class="hljs-number">10.0</span>)), ((<span class="hljs-number">1.0</span>, <span class="hljs-number">3.0</span>)), ((<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>));
            </code></pre><br>
            Now a question arises: how to order complex numbers if no order relation is defined for them in the mathematical sense?<br>
            <br>
            As it turns out, comparison operators are already defined for us:<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> numbers <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> x;
            </code></pre><pre><code class="plaintext hljs">   x    
            --------
             (0,10)
             (1,1)
             (1,3)
            (3 rows)
            </code></pre><br>
            By default, sorting is componentwise for a composite type: first fields are compared, then second fields, and so on, roughly the same way as text strings are compared character-by-character. But we can define a different order. For example, complex numbers can be treated as vectors and ordered by the modulus (length), which is computed as the square root of the sum of squares of the coordinates (the Pythagoras' theorem). To define such an order, let's create an auxiliary function that computes the modulus:<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> modulus(a complex) <span class="hljs-keyword">returns</span> <span class="hljs-type">float</span> <span class="hljs-keyword">as</span> $$<span class="pgsql">
                <span class="hljs-keyword">select</span> sqrt(a.re*a.re + a.im*a.im);
            $$</span> <span class="hljs-keyword">immutable</span> <span class="hljs-keyword">language</span> <span class="hljs-keyword">sql</span>;
            </code></pre><br>
            Now we will systematically define functions for all the five comparison operators using this auxiliary function:<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> complex_lt(a complex, b complex) <span class="hljs-keyword">returns</span> <span class="hljs-type">boolean</span> <span class="hljs-keyword">as</span> $$<span class="pgsql">
                <span class="hljs-keyword">select</span> modulus(a) &lt; modulus(b);
            $$</span> <span class="hljs-keyword">immutable</span> <span class="hljs-keyword">language</span> <span class="hljs-keyword">sql</span>;
            
            postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> complex_le(a complex, b complex) <span class="hljs-keyword">returns</span> <span class="hljs-type">boolean</span> <span class="hljs-keyword">as</span> $$<span class="pgsql">
                <span class="hljs-keyword">select</span> modulus(a) &lt;= modulus(b);
            $$</span> <span class="hljs-keyword">immutable</span> <span class="hljs-keyword">language</span> <span class="hljs-keyword">sql</span>;
            
            postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> complex_eq(a complex, b complex) <span class="hljs-keyword">returns</span> <span class="hljs-type">boolean</span> <span class="hljs-keyword">as</span> $$<span class="pgsql">
                <span class="hljs-keyword">select</span> modulus(a) = modulus(b);
            $$</span> <span class="hljs-keyword">immutable</span> <span class="hljs-keyword">language</span> <span class="hljs-keyword">sql</span>;
            
            postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> complex_ge(a complex, b complex) <span class="hljs-keyword">returns</span> <span class="hljs-type">boolean</span> <span class="hljs-keyword">as</span> $$<span class="pgsql">
                <span class="hljs-keyword">select</span> modulus(a) &gt;= modulus(b);
            $$</span> <span class="hljs-keyword">immutable</span> <span class="hljs-keyword">language</span> <span class="hljs-keyword">sql</span>;
            
            postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> complex_gt(a complex, b complex) <span class="hljs-keyword">returns</span> <span class="hljs-type">boolean</span> <span class="hljs-keyword">as</span> $$<span class="pgsql">
                <span class="hljs-keyword">select</span> modulus(a) &gt; modulus(b);
            $$</span> <span class="hljs-keyword">immutable</span> <span class="hljs-keyword">language</span> <span class="hljs-keyword">sql</span>;
            </code></pre><br>
            And we'll create corresponding operators. To illustrate that they do not need to be called "&gt;", "&lt;", and so on, let's give them «weird» names.<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">operator</span> #&lt;#(leftarg=complex, rightarg=complex, procedure=complex_lt);
            
            postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">operator</span> #&lt;=#(leftarg=complex, rightarg=complex, procedure=complex_le);
            
            postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">operator</span> #=#(leftarg=complex, rightarg=complex, procedure=complex_eq);
            
            postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">operator</span> #&gt;=#(leftarg=complex, rightarg=complex, procedure=complex_ge);
            
            postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">operator</span> #&gt;#(leftarg=complex, rightarg=complex, procedure=complex_gt);
            </code></pre><br>
            At this point, we can compare numbers:<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">select</span> (<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>)::complex #&lt;# (<span class="hljs-number">1.0</span>,<span class="hljs-number">3.0</span>)::complex;
            </code></pre><pre><code class="plaintext hljs"> ?column?
            ----------
             t
            (1 row)
            </code></pre><br>
            In addition to five operators, «btree» access method requires one more function (excessive but convenient) to be defined: it must return -1, 0, or 1 if the first value is less than, equal to, or greater than the second one. This auxiliary function is called support. Other access methods can require defining other support functions.<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> complex_cmp(a complex, b complex) <span class="hljs-keyword">returns</span> <span class="hljs-type">integer</span> <span class="hljs-keyword">as</span> $$<span class="pgsql">
                <span class="hljs-keyword">select</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> modulus(a) &lt; modulus(b) <span class="hljs-keyword">then</span> <span class="hljs-number">-1</span>
                            <span class="hljs-keyword">when</span> modulus(a) &gt; modulus(b) <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> 
                            <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
                       <span class="hljs-keyword">end</span>;
            $$</span> <span class="hljs-keyword">language</span> <span class="hljs-keyword">sql</span>;
            </code></pre><br>
            Now we are ready to create an operator class (and same-name operator family will be created automatically):<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">class</span> complex_ops
            <span class="hljs-keyword">default</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">type</span> complex
            <span class="hljs-keyword">using</span> btree <span class="hljs-keyword">as</span>
                <span class="hljs-keyword">operator</span> <span class="hljs-number">1</span> #&lt;#,
                <span class="hljs-keyword">operator</span> <span class="hljs-number">2</span> #&lt;=#,
                <span class="hljs-keyword">operator</span> <span class="hljs-number">3</span> #=#,
                <span class="hljs-keyword">operator</span> <span class="hljs-number">4</span> #&gt;=#,
                <span class="hljs-keyword">operator</span> <span class="hljs-number">5</span> #&gt;#,
                <span class="hljs-keyword">function</span> <span class="hljs-number">1</span> complex_cmp(complex,complex);
            </code></pre><br>
            Now sorting works as desired:<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> numbers <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> x;
            </code></pre><pre><code class="plaintext hljs">   x    
            --------
             (1,1)
             (1,3)
             (0,10)
            (3 rows)
            </code></pre><br>
            And it will certainly be supported by «btree» index.<br>
            <br>
            To complete the picture, you can get support functions using this query:<br>
            <br>
            <pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword">select</span> amp.amprocnum,
                   amp.amproc,
                   amp.amproclefttype::<span class="hljs-type">regtype</span>,
                   amp.amprocrighttype::<span class="hljs-type">regtype</span>
            <span class="hljs-keyword">from</span>   pg_opfamily opf,
                   pg_am am,
                   pg_amproc amp
            <span class="hljs-keyword">where</span>  opf.opfname = <span class="hljs-string">'complex_ops'</span>
            <span class="hljs-keyword">and</span>    opf.opfmethod = am.oid
            <span class="hljs-keyword">and</span>    am.amname = <span class="hljs-string">'btree'</span>
            <span class="hljs-keyword">and</span>    amp.amprocfamily = opf.oid;
            </code></pre><pre><code class="plaintext hljs"> amprocnum |   amproc    | amproclefttype | amprocrighttype
            -----------+-------------+----------------+-----------------
                     1 | complex_cmp | complex        | complex
            (1 row)
            </code></pre><br>
            <h2>Internals</h2><br>
            We can explore the internal structure of B-tree using «pageinspect» extension.<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">create</span> <span class="hljs-keyword">extension</span> pageinspect;
            </code></pre><br>
            Index metapage:<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> bt_metap(<span class="hljs-string">'ticket_flights_pkey'</span>);
            </code></pre><pre><code class="plaintext hljs"> magic  | version | root | level | fastroot | fastlevel
            --------+---------+------+-------+----------+-----------
             340322 |       2 |  164 |     2 |      164 |         2
            (1 row)
            </code></pre><br>
            The most interesting here is the index level: the index on two columns for a table with one million rows required as few as 2 levels (not including the root).<br>
            <br>
            Statistical information on block 164 (root):<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">select</span> <span class="hljs-keyword">type</span>, live_items, dead_items, avg_item_size, page_size, free_size
            <span class="hljs-keyword">from</span> bt_page_stats(<span class="hljs-string">'ticket_flights_pkey'</span>,<span class="hljs-number">164</span>);
            </code></pre><pre><code class="plaintext hljs"> type | live_items | dead_items | avg_item_size | page_size | free_size
            ------+------------+------------+---------------+-----------+-----------
             r    |         33 |          0 |            31 |      8192 |      6984
            (1 row)
            </code></pre><br>
            And the data in the block (the «data» field, which is here sacrificed to the screen width, contains the value of the indexing key in binary representation):<br>
            <br>
            <pre><code class="pgsql hljs">demo=# <span class="hljs-keyword">select</span> itemoffset, ctid, itemlen, left(data,<span class="hljs-number">56</span>) <span class="hljs-keyword">as</span> data
            <span class="hljs-keyword">from</span> bt_page_items(<span class="hljs-string">'ticket_flights_pkey'</span>,<span class="hljs-number">164</span>) <span class="hljs-keyword">limit</span> <span class="hljs-number">5</span>;
            </code></pre><pre><code class="plaintext hljs"> itemoffset |  ctid   | itemlen |                           data                           
            ------------+---------+---------+----------------------------------------------------------
                      1 | (3,1)   |       8 |
                      2 | (163,1) |      32 | 1d 30 30 30 35 34 33 32 33 30 35 37 37 31 00 00 ff 5f 00
                      3 | (323,1) |      32 | 1d 30 30 30 35 34 33 32 34 32 33 36 36 32 00 00 4f 78 00
                      4 | (482,1) |      32 | 1d 30 30 30 35 34 33 32 35 33 30 38 39 33 00 00 4d 1e 00
                      5 | (641,1) |      32 | 1d 30 30 30 35 34 33 32 36 35 35 37 38 35 00 00 2b 09 00
            (5 rows)
            </code></pre><br>
            The first element pertains to techniques and specifies the upper bound of all elements in the block (an implementation detail that we did not discuss), while the data itself starts with the second element. It is clear that the leftmost child node is block 163, followed by block 323, and so on. They, in turn, can be explored using the same functions.<br>
            <br>
            Now, following a good tradition, it makes sense to read the documentation, <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/access/nbtree/README;hb=HEAD">README</a>, and source code.<br>
            <br>
            Yet one more potentially useful extension is "<a href="https://postgrespro.com/docs/postgresql/10/amcheck">amcheck</a>", which will be incorporated in PostgreSQL 10, and for lower versions you can get it from <a href="https://github.com/petergeoghegan/amcheck">github</a>. This extension checks logical consistency of data in B-trees and enables us to detect faults in advance.<br>
            <blockquote>That's true, «amcheck» is a part of PostgreSQL starting from version 10.<br>
            </blockquote><a href="https://habr.com/ru/company/postgrespro/blog/444742/">Read on</a>.</div>
                  
                </div>
            
              </div>
            
              </div>
          </div>
        </div>
    </main>
    <div data-include="footer"></div>
   
	<!-- JS here -->
	
		<!-- All JS Custom Plugins Link Here here -->
        <script src="./assets/js/vendor/modernizr-3.5.0.min.js"></script>
		<!-- Jquery, Popper, Bootstrap -->
		<script src="./assets/js/vendor/jquery-1.12.4.min.js"></script>
        <script src="./assets/js/popper.min.js"></script>
        <script src="./assets/js/bootstrap.min.js"></script>
	    <!-- Jquery Mobile Menu -->
        <script src="./assets/js/jquery.slicknav.min.js"></script>

		<!-- Jquery Slick , Owl-Carousel Plugins -->
        <script src="./assets/js/owl.carousel.min.js"></script>
        <script src="./assets/js/slick.min.js"></script>
        <!-- Date Picker -->
        <script src="./assets/js/gijgo.min.js"></script>
		<!-- One Page, Animated-HeadLin -->
        <script src="./assets/js/wow.min.js"></script>
		<script src="./assets/js/animated.headline.js"></script>
        <script src="./assets/js/jquery.magnific-popup.js"></script>

        <!-- Breaking New Pluging -->
        <script src="./assets/js/jquery.ticker.js"></script>
        <script src="./assets/js/site.js"></script>

		<!-- Scrollup, nice-select, sticky -->
        <script src="./assets/js/jquery.scrollUp.min.js"></script>
        <script src="./assets/js/jquery.nice-select.min.js"></script>
		<script src="./assets/js/jquery.sticky.js"></script>
        
        <!-- contact js -->
        <script src="./assets/js/contact.js"></script>
        <script src="./assets/js/jquery.form.js"></script>
        <script src="./assets/js/jquery.validate.min.js"></script>
        <script src="./assets/js/mail-script.js"></script>
        <script src="./assets/js/jquery.ajaxchimp.min.js"></script>
        
		<!-- Jquery Plugins, main Jquery -->	
        <script src="./assets/js/plugins.js"></script>
        <script src="./assets/js/main.js"></script>
        
        <!-- Header Date -->
        <script src="./assets/js/header.date.js"></script>
        <!-- Weather API-->
        <script src="./assets/js/weatherapi.js"></script>
        <script src="./assets/js/include.js"></script>
        
    </body>
</html>